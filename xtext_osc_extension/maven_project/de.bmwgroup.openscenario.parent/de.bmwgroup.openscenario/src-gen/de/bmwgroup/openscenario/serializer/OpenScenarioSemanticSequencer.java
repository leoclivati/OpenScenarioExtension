/*
 * generated by Xtext 2.35.0
 */
package de.bmwgroup.openscenario.serializer;

import com.google.inject.Inject;
import de.bmwgroup.openscenario.openScenario.ActionDeclaration;
import de.bmwgroup.openscenario.openScenario.ActorDeclaration;
import de.bmwgroup.openscenario.openScenario.ArgumentList;
import de.bmwgroup.openscenario.openScenario.ArgumentListSpecification;
import de.bmwgroup.openscenario.openScenario.ArgumentSpecification;
import de.bmwgroup.openscenario.openScenario.BehaviorInvocation;
import de.bmwgroup.openscenario.openScenario.BehaviorWithDeclaration;
import de.bmwgroup.openscenario.openScenario.CallDirective;
import de.bmwgroup.openscenario.openScenario.CastExpTail;
import de.bmwgroup.openscenario.openScenario.Composition;
import de.bmwgroup.openscenario.openScenario.Condition;
import de.bmwgroup.openscenario.openScenario.CoverageDeclaration;
import de.bmwgroup.openscenario.openScenario.DoDirective;
import de.bmwgroup.openscenario.openScenario.DoDirectiveMember;
import de.bmwgroup.openscenario.openScenario.ElapsedExpression;
import de.bmwgroup.openscenario.openScenario.ElementAccessTail;
import de.bmwgroup.openscenario.openScenario.EmitDirective;
import de.bmwgroup.openscenario.openScenario.EnumDeclaration;
import de.bmwgroup.openscenario.openScenario.EnumMemberDeclaration;
import de.bmwgroup.openscenario.openScenario.EnumTypeExtension;
import de.bmwgroup.openscenario.openScenario.EnumValueReference;
import de.bmwgroup.openscenario.openScenario.EventDeclaration;
import de.bmwgroup.openscenario.openScenario.EventPath;
import de.bmwgroup.openscenario.openScenario.EventReference;
import de.bmwgroup.openscenario.openScenario.EventSpecification;
import de.bmwgroup.openscenario.openScenario.EveryExpression;
import de.bmwgroup.openscenario.openScenario.FallExpression;
import de.bmwgroup.openscenario.openScenario.FieldAccessTail;
import de.bmwgroup.openscenario.openScenario.GlobalParameterDeclaration;
import de.bmwgroup.openscenario.openScenario.ImportStatement;
import de.bmwgroup.openscenario.openScenario.KeepConstraintDeclaration;
import de.bmwgroup.openscenario.openScenario.ListConstructor;
import de.bmwgroup.openscenario.openScenario.MethodDeclaration;
import de.bmwgroup.openscenario.openScenario.MethodImplementation;
import de.bmwgroup.openscenario.openScenario.ModifierDeclaration;
import de.bmwgroup.openscenario.openScenario.NamedArgument;
import de.bmwgroup.openscenario.openScenario.OnDirective;
import de.bmwgroup.openscenario.openScenario.OpenScenarioPackage;
import de.bmwgroup.openscenario.openScenario.OscFile;
import de.bmwgroup.openscenario.openScenario.ParameterDeclaration;
import de.bmwgroup.openscenario.openScenario.ParameterWithDeclaration;
import de.bmwgroup.openscenario.openScenario.PhysicalType;
import de.bmwgroup.openscenario.openScenario.PhysicalTypeDeclaration;
import de.bmwgroup.openscenario.openScenario.PostfixExp;
import de.bmwgroup.openscenario.openScenario.RangeConstructor;
import de.bmwgroup.openscenario.openScenario.RemoveDefaultDeclaration;
import de.bmwgroup.openscenario.openScenario.RiseExpression;
import de.bmwgroup.openscenario.openScenario.SIBaseExponent;
import de.bmwgroup.openscenario.openScenario.SIBaseExponentList;
import de.bmwgroup.openscenario.openScenario.SIBaseUnitSpecifier;
import de.bmwgroup.openscenario.openScenario.SIUnitSpecifier;
import de.bmwgroup.openscenario.openScenario.SampleExpression;
import de.bmwgroup.openscenario.openScenario.ScenarioDeclaration;
import de.bmwgroup.openscenario.openScenario.StructDeclaration;
import de.bmwgroup.openscenario.openScenario.StructuredID;
import de.bmwgroup.openscenario.openScenario.StructuredTypeExtension;
import de.bmwgroup.openscenario.openScenario.TypeTestTail;
import de.bmwgroup.openscenario.openScenario.UnitDeclaration;
import de.bmwgroup.openscenario.openScenario.UntilDirective;
import de.bmwgroup.openscenario.openScenario.VariableDeclaration;
import de.bmwgroup.openscenario.openScenario.WaitDirective;
import de.bmwgroup.openscenario.services.OpenScenarioGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class OpenScenarioSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OpenScenarioGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OpenScenarioPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OpenScenarioPackage.ACTION_DECLARATION:
				sequence_ActionDeclaration(context, (ActionDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.ACTOR_DECLARATION:
				sequence_ActorDeclaration(context, (ActorDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.ARGUMENT_LIST:
				sequence_ArgumentList(context, (ArgumentList) semanticObject); 
				return; 
			case OpenScenarioPackage.ARGUMENT_LIST_SPECIFICATION:
				sequence_ArgumentListSpecification(context, (ArgumentListSpecification) semanticObject); 
				return; 
			case OpenScenarioPackage.ARGUMENT_SPECIFICATION:
				sequence_ArgumentSpecification(context, (ArgumentSpecification) semanticObject); 
				return; 
			case OpenScenarioPackage.BEHAVIOR_INVOCATION:
				sequence_BehaviorInvocation(context, (BehaviorInvocation) semanticObject); 
				return; 
			case OpenScenarioPackage.BEHAVIOR_WITH_DECLARATION:
				sequence_BehaviorWithDeclaration(context, (BehaviorWithDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.CALL_DIRECTIVE:
				sequence_CallDirective(context, (CallDirective) semanticObject); 
				return; 
			case OpenScenarioPackage.CAST_EXP_TAIL:
				sequence_CastExpTail(context, (CastExpTail) semanticObject); 
				return; 
			case OpenScenarioPackage.COMPOSITION:
				sequence_Composition(context, (Composition) semanticObject); 
				return; 
			case OpenScenarioPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case OpenScenarioPackage.COVERAGE_DECLARATION:
				sequence_CoverageDeclaration(context, (CoverageDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.DO_DIRECTIVE:
				sequence_DoDirective(context, (DoDirective) semanticObject); 
				return; 
			case OpenScenarioPackage.DO_DIRECTIVE_MEMBER:
				sequence_DoDirectiveMember(context, (DoDirectiveMember) semanticObject); 
				return; 
			case OpenScenarioPackage.ELAPSED_EXPRESSION:
				sequence_ElapsedExpression(context, (ElapsedExpression) semanticObject); 
				return; 
			case OpenScenarioPackage.ELEMENT_ACCESS_TAIL:
				sequence_ElementAccessTail(context, (ElementAccessTail) semanticObject); 
				return; 
			case OpenScenarioPackage.EMIT_DIRECTIVE:
				sequence_EmitDirective(context, (EmitDirective) semanticObject); 
				return; 
			case OpenScenarioPackage.ENUM_DECLARATION:
				sequence_EnumDeclaration(context, (EnumDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.ENUM_MEMBER_DECLARATION:
				sequence_EnumMemberDeclaration(context, (EnumMemberDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.ENUM_TYPE_EXTENSION:
				sequence_EnumTypeExtension(context, (EnumTypeExtension) semanticObject); 
				return; 
			case OpenScenarioPackage.ENUM_VALUE_REFERENCE:
				sequence_EnumValueReference(context, (EnumValueReference) semanticObject); 
				return; 
			case OpenScenarioPackage.EVENT_DECLARATION:
				sequence_EventDeclaration(context, (EventDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.EVENT_PATH:
				sequence_EventPath(context, (EventPath) semanticObject); 
				return; 
			case OpenScenarioPackage.EVENT_REFERENCE:
				sequence_EventReference(context, (EventReference) semanticObject); 
				return; 
			case OpenScenarioPackage.EVENT_SPECIFICATION:
				sequence_EventSpecification(context, (EventSpecification) semanticObject); 
				return; 
			case OpenScenarioPackage.EVERY_EXPRESSION:
				sequence_EveryExpression(context, (EveryExpression) semanticObject); 
				return; 
			case OpenScenarioPackage.FALL_EXPRESSION:
				sequence_FallExpression(context, (FallExpression) semanticObject); 
				return; 
			case OpenScenarioPackage.FIELD_ACCESS_TAIL:
				sequence_FieldAccessTail(context, (FieldAccessTail) semanticObject); 
				return; 
			case OpenScenarioPackage.GLOBAL_PARAMETER_DECLARATION:
				sequence_GlobalParameterDeclaration(context, (GlobalParameterDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.IMPORT_STATEMENT:
				sequence_ImportStatement(context, (ImportStatement) semanticObject); 
				return; 
			case OpenScenarioPackage.KEEP_CONSTRAINT_DECLARATION:
				sequence_KeepConstraintDeclaration(context, (KeepConstraintDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.LIST_CONSTRUCTOR:
				sequence_ListConstructor(context, (ListConstructor) semanticObject); 
				return; 
			case OpenScenarioPackage.METHOD_DECLARATION:
				sequence_MethodDeclaration(context, (MethodDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.METHOD_IMPLEMENTATION:
				sequence_MethodImplementation(context, (MethodImplementation) semanticObject); 
				return; 
			case OpenScenarioPackage.MODIFIER_DECLARATION:
				sequence_ModifierDeclaration(context, (ModifierDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.NAMED_ARGUMENT:
				sequence_NamedArgument(context, (NamedArgument) semanticObject); 
				return; 
			case OpenScenarioPackage.ON_DIRECTIVE:
				sequence_OnDirective(context, (OnDirective) semanticObject); 
				return; 
			case OpenScenarioPackage.OSC_FILE:
				sequence_OscFile(context, (OscFile) semanticObject); 
				return; 
			case OpenScenarioPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.PARAMETER_WITH_DECLARATION:
				sequence_ParameterWithDeclaration(context, (ParameterWithDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.PHYSICAL_TYPE:
				sequence_PhysicalType(context, (PhysicalType) semanticObject); 
				return; 
			case OpenScenarioPackage.PHYSICAL_TYPE_DECLARATION:
				sequence_PhysicalTypeDeclaration(context, (PhysicalTypeDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.POSTFIX_EXP:
				if (rule == grammarAccess.getMethodInvocationRule()) {
					sequence_MethodInvocation_PostfixExp(context, (PostfixExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParameterReferenceRule()) {
					sequence_ParameterReference_PostfixExp(context, (PostfixExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixExpRule()
						|| rule == grammarAccess.getFactorRule()) {
					sequence_PostfixExp(context, (PostfixExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEventConditionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getRelationRule()) {
					sequence_PostfixExp_Relation_Sum_Term(context, (PostfixExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSumRule()) {
					sequence_PostfixExp_Sum_Term(context, (PostfixExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTermRule()) {
					sequence_PostfixExp_Term(context, (PostfixExp) semanticObject); 
					return; 
				}
				else break;
			case OpenScenarioPackage.RANGE_CONSTRUCTOR:
				sequence_RangeConstructor(context, (RangeConstructor) semanticObject); 
				return; 
			case OpenScenarioPackage.REMOVE_DEFAULT_DECLARATION:
				sequence_RemoveDefaultDeclaration(context, (RemoveDefaultDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.RISE_EXPRESSION:
				sequence_RiseExpression(context, (RiseExpression) semanticObject); 
				return; 
			case OpenScenarioPackage.SI_BASE_EXPONENT:
				sequence_SIBaseExponent(context, (SIBaseExponent) semanticObject); 
				return; 
			case OpenScenarioPackage.SI_BASE_EXPONENT_LIST:
				sequence_SIBaseExponentList(context, (SIBaseExponentList) semanticObject); 
				return; 
			case OpenScenarioPackage.SI_BASE_UNIT_SPECIFIER:
				sequence_SIBaseUnitSpecifier(context, (SIBaseUnitSpecifier) semanticObject); 
				return; 
			case OpenScenarioPackage.SI_UNIT_SPECIFIER:
				sequence_SIUnitSpecifier(context, (SIUnitSpecifier) semanticObject); 
				return; 
			case OpenScenarioPackage.SAMPLE_EXPRESSION:
				sequence_SampleExpression(context, (SampleExpression) semanticObject); 
				return; 
			case OpenScenarioPackage.SCENARIO_DECLARATION:
				sequence_ScenarioDeclaration(context, (ScenarioDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.STRUCT_DECLARATION:
				sequence_StructDeclaration(context, (StructDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.STRUCTURED_ID:
				sequence_StructuredID(context, (StructuredID) semanticObject); 
				return; 
			case OpenScenarioPackage.STRUCTURED_TYPE_EXTENSION:
				sequence_StructuredTypeExtension(context, (StructuredTypeExtension) semanticObject); 
				return; 
			case OpenScenarioPackage.TYPE_TEST_TAIL:
				sequence_TypeTestTail(context, (TypeTestTail) semanticObject); 
				return; 
			case OpenScenarioPackage.UNIT_DECLARATION:
				sequence_UnitDeclaration(context, (UnitDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.UNTIL_DIRECTIVE:
				sequence_UntilDirective(context, (UntilDirective) semanticObject); 
				return; 
			case OpenScenarioPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case OpenScenarioPackage.WAIT_DIRECTIVE:
				sequence_WaitDirective(context, (WaitDirective) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns ActionDeclaration
	 *     ActionDeclaration returns ActionDeclaration
	 *
	 * Constraint:
	 *     (name=ID (baseActionName=ID (fieldName=ID enumReference=EnumValueReference?)?)? ActionMemberDecl+=MemberDeclaration*)
	 * </pre>
	 */
	protected void sequence_ActionDeclaration(ISerializationContext context, ActionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns ActorDeclaration
	 *     ActorDeclaration returns ActorDeclaration
	 *
	 * Constraint:
	 *     (name=ID (baseActorName=ID (fieldName=ID enumReference=EnumValueReference?)?)? ActorMemberDecl+=MemberDeclaration*)
	 * </pre>
	 */
	protected void sequence_ActorDeclaration(ISerializationContext context, ActorDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArgumentListSpecification returns ArgumentListSpecification
	 *
	 * Constraint:
	 *     (argumentSpecification+=ArgumentSpecification argumentSpecification+=ArgumentSpecification)
	 * </pre>
	 */
	protected void sequence_ArgumentListSpecification(ISerializationContext context, ArgumentListSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArgumentList returns ArgumentList
	 *
	 * Constraint:
	 *     (
	 *         (positionalArguments+=Expression positionalArguments+=Expression* namedArguments+=NamedArgument*) | 
	 *         (namedArguments+=NamedArgument namedArguments+=NamedArgument*)
	 *     )
	 * </pre>
	 */
	protected void sequence_ArgumentList(ISerializationContext context, ArgumentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArgumentSpecification returns ArgumentSpecification
	 *
	 * Constraint:
	 *     (argumentName=ID typeDeclarator=TypeDeclarator defaultValue=Expression?)
	 * </pre>
	 */
	protected void sequence_ArgumentSpecification(ISerializationContext context, ArgumentSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BehaviorInvocation returns BehaviorInvocation
	 *     BehaviorWithMember returns BehaviorInvocation
	 *
	 * Constraint:
	 *     (actorExpression=Expression argumentList=ArgumentList?)
	 * </pre>
	 */
	protected void sequence_BehaviorInvocation(ISerializationContext context, BehaviorInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BehaviorWithDeclaration returns BehaviorWithDeclaration
	 *
	 * Constraint:
	 *     behaviorWithMembers+=BehaviorWithMember+
	 * </pre>
	 */
	protected void sequence_BehaviorWithDeclaration(ISerializationContext context, BehaviorWithDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OnDirectiveMember returns CallDirective
	 *     CallDirective returns CallDirective
	 *
	 * Constraint:
	 *     methodInvocation=MethodInvocation
	 * </pre>
	 */
	protected void sequence_CallDirective(ISerializationContext context, CallDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.CALL_DIRECTIVE__METHOD_INVOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.CALL_DIRECTIVE__METHOD_INVOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCallDirectiveAccess().getMethodInvocationMethodInvocationParserRuleCall_1_0(), semanticObject.getMethodInvocation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExpTail returns CastExpTail
	 *     CastExpTail returns CastExpTail
	 *
	 * Constraint:
	 *     typeDeclarator+=TypeDeclarator
	 * </pre>
	 */
	protected void sequence_CastExpTail(ISerializationContext context, CastExpTail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Composition returns Composition
	 *
	 * Constraint:
	 *     (compositionOp=CompositionOptions argumentList=ArgumentList? (doMembers+=DoDirectiveMember withDeclaration+=BehaviorWithDeclaration?)*)
	 * </pre>
	 */
	protected void sequence_Composition(ISerializationContext context, Composition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventCondition returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (condition=Expression trueResult=Expression falseResult=Expression)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.CONDITION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.CONDITION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.CONDITION__TRUE_RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.CONDITION__TRUE_RESULT));
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.CONDITION__FALSE_RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.CONDITION__FALSE_RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getConditionExpressionParserRuleCall_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionAccess().getTrueResultExpressionParserRuleCall_2_0(), semanticObject.getTrueResult());
		feeder.accept(grammarAccess.getConditionAccess().getFalseResultExpressionParserRuleCall_4_0(), semanticObject.getFalseResult());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtensionMemberDeclaration returns CoverageDeclaration
	 *     MemberDeclaration returns CoverageDeclaration
	 *     CoverageDeclaration returns CoverageDeclaration
	 *
	 * Constraint:
	 *     argumentList=ArgumentList
	 * </pre>
	 */
	protected void sequence_CoverageDeclaration(ISerializationContext context, CoverageDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.COVERAGE_DECLARATION__ARGUMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.COVERAGE_DECLARATION__ARGUMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCoverageDeclarationAccess().getArgumentListArgumentListParserRuleCall_2_0(), semanticObject.getArgumentList());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DoDirectiveMember returns DoDirectiveMember
	 *
	 * Constraint:
	 *     (
	 *         labelName=ID? 
	 *         (
	 *             composition=Composition | 
	 *             emitDirective=EmitDirective | 
	 *             callDirective=CallDirective | 
	 *             waitDirective=WaitDirective | 
	 *             behaviorInvocation=BehaviorInvocation
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_DoDirectiveMember(ISerializationContext context, DoDirectiveMember semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtensionMemberDeclaration returns DoDirective
	 *     BehaviorSpecification returns DoDirective
	 *     DoDirective returns DoDirective
	 *
	 * Constraint:
	 *     doMembers=DoDirectiveMember
	 * </pre>
	 */
	protected void sequence_DoDirective(ISerializationContext context, DoDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.DO_DIRECTIVE__DO_MEMBERS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.DO_DIRECTIVE__DO_MEMBERS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoDirectiveAccess().getDoMembersDoDirectiveMemberParserRuleCall_1_0(), semanticObject.getDoMembers());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventCondition returns ElapsedExpression
	 *     ElapsedExpression returns ElapsedExpression
	 *
	 * Constraint:
	 *     durationExpression=Expression
	 * </pre>
	 */
	protected void sequence_ElapsedExpression(ISerializationContext context, ElapsedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.ELAPSED_EXPRESSION__DURATION_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.ELAPSED_EXPRESSION__DURATION_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElapsedExpressionAccess().getDurationExpressionExpressionParserRuleCall_2_0(), semanticObject.getDurationExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElementAccessTail returns ElementAccessTail
	 *
	 * Constraint:
	 *     expression+=Expression
	 * </pre>
	 */
	protected void sequence_ElementAccessTail(ISerializationContext context, ElementAccessTail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OnDirectiveMember returns EmitDirective
	 *     EmitDirective returns EmitDirective
	 *
	 * Constraint:
	 *     (eventName=ID argumentList=ArgumentList)
	 * </pre>
	 */
	protected void sequence_EmitDirective(ISerializationContext context, EmitDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.EMIT_DIRECTIVE__EVENT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.EMIT_DIRECTIVE__EVENT_NAME));
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.EMIT_DIRECTIVE__ARGUMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.EMIT_DIRECTIVE__ARGUMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmitDirectiveAccess().getEventNameIDTerminalRuleCall_1_0(), semanticObject.getEventName());
		feeder.accept(grammarAccess.getEmitDirectiveAccess().getArgumentListArgumentListParserRuleCall_3_0(), semanticObject.getArgumentList());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns EnumDeclaration
	 *     EnumDeclaration returns EnumDeclaration
	 *
	 * Constraint:
	 *     (enumName=ID enumMemberDecls+=EnumMemberDeclaration enumMemberDecls+=EnumMemberDeclaration*)
	 * </pre>
	 */
	protected void sequence_EnumDeclaration(ISerializationContext context, EnumDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumMemberDeclaration returns EnumMemberDeclaration
	 *
	 * Constraint:
	 *     (enumMemberName=ID enumMemberValue=INTEGER?)
	 * </pre>
	 */
	protected void sequence_EnumMemberDeclaration(ISerializationContext context, EnumMemberDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns EnumTypeExtension
	 *     TypeExtension returns EnumTypeExtension
	 *     EnumTypeExtension returns EnumTypeExtension
	 *
	 * Constraint:
	 *     (enumName=ID enumMemberDecls+=EnumMemberDeclaration enumMemberDecls+=EnumMemberDeclaration*)
	 * </pre>
	 */
	protected void sequence_EnumTypeExtension(ISerializationContext context, EnumTypeExtension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumValueReference returns EnumValueReference
	 *     PrimaryExp returns EnumValueReference
	 *     ValueExp returns EnumValueReference
	 *
	 * Constraint:
	 *     (enumName=ID? enumMemberName=ID)
	 * </pre>
	 */
	protected void sequence_EnumValueReference(ISerializationContext context, EnumValueReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtensionMemberDeclaration returns EventDeclaration
	 *     MemberDeclaration returns EventDeclaration
	 *     EventDeclaration returns EventDeclaration
	 *
	 * Constraint:
	 *     (eventName=ID (params+=ArgumentListSpecification params+=ArgumentListSpecification*)? eventSpecification=EventSpecification?)
	 * </pre>
	 */
	protected void sequence_EventDeclaration(ISerializationContext context, EventDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventPath returns EventPath
	 *
	 * Constraint:
	 *     (expression=Expression? eventName=ID)
	 * </pre>
	 */
	protected void sequence_EventPath(ISerializationContext context, EventPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventReference returns EventReference
	 *
	 * Constraint:
	 *     eventPath=EventPath
	 * </pre>
	 */
	protected void sequence_EventReference(ISerializationContext context, EventReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.EVENT_REFERENCE__EVENT_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.EVENT_REFERENCE__EVENT_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventReferenceAccess().getEventPathEventPathParserRuleCall_1_0(), semanticObject.getEventPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventSpecification returns EventSpecification
	 *
	 * Constraint:
	 *     ((eventReference=EventReference (eventFieldName=ID? eventCondition=EventCondition)?) | eventCondition=EventCondition)
	 * </pre>
	 */
	protected void sequence_EventSpecification(ISerializationContext context, EventSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventCondition returns EveryExpression
	 *     EveryExpression returns EveryExpression
	 *
	 * Constraint:
	 *     (durationExpression=Expression NextdurationExpression+=Expression?)
	 * </pre>
	 */
	protected void sequence_EveryExpression(ISerializationContext context, EveryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventCondition returns FallExpression
	 *     FallExpression returns FallExpression
	 *
	 * Constraint:
	 *     boolExpression=Expression
	 * </pre>
	 */
	protected void sequence_FallExpression(ISerializationContext context, FallExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.FALL_EXPRESSION__BOOL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.FALL_EXPRESSION__BOOL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFallExpressionAccess().getBoolExpressionExpressionParserRuleCall_2_0(), semanticObject.getBoolExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExpTail returns FieldAccessTail
	 *     FieldAccessTail returns FieldAccessTail
	 *
	 * Constraint:
	 *     fieldName+=ID
	 * </pre>
	 */
	protected void sequence_FieldAccessTail(ISerializationContext context, FieldAccessTail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns GlobalParameterDeclaration
	 *     GlobalParameterDeclaration returns GlobalParameterDeclaration
	 *
	 * Constraint:
	 *     parameterDeclaration=ParameterDeclaration
	 * </pre>
	 */
	protected void sequence_GlobalParameterDeclaration(ISerializationContext context, GlobalParameterDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.GLOBAL_PARAMETER_DECLARATION__PARAMETER_DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.GLOBAL_PARAMETER_DECLARATION__PARAMETER_DECLARATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalParameterDeclarationAccess().getParameterDeclarationParameterDeclarationParserRuleCall_1_0(), semanticObject.getParameterDeclaration());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PreludeStatement returns ImportStatement
	 *     ImportStatement returns ImportStatement
	 *
	 * Constraint:
	 *     importReference=ImportReference
	 * </pre>
	 */
	protected void sequence_ImportStatement(ISerializationContext context, ImportStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.IMPORT_STATEMENT__IMPORT_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.IMPORT_STATEMENT__IMPORT_REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportStatementAccess().getImportReferenceImportReferenceParserRuleCall_1_0(), semanticObject.getImportReference());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtensionMemberDeclaration returns KeepConstraintDeclaration
	 *     MemberDeclaration returns KeepConstraintDeclaration
	 *     BehaviorWithMember returns KeepConstraintDeclaration
	 *     ConstraintDeclaration returns KeepConstraintDeclaration
	 *     KeepConstraintDeclaration returns KeepConstraintDeclaration
	 *
	 * Constraint:
	 *     (constraintQualifier=ConstraintQualifier? constraintExpression=Expression)
	 * </pre>
	 */
	protected void sequence_KeepConstraintDeclaration(ISerializationContext context, KeepConstraintDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExp returns ListConstructor
	 *     ListConstructor returns ListConstructor
	 *
	 * Constraint:
	 *     (elements+=ValueExp elements+=ValueExp*)
	 * </pre>
	 */
	protected void sequence_ListConstructor(ISerializationContext context, ListConstructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtensionMemberDeclaration returns MethodDeclaration
	 *     MemberDeclaration returns MethodDeclaration
	 *     MethodDeclaration returns MethodDeclaration
	 *
	 * Constraint:
	 *     (methodName=ID argumentListSpecification=ArgumentListSpecification? returnType=TypeDeclarator? methodImplementation=MethodImplementation)
	 * </pre>
	 */
	protected void sequence_MethodDeclaration(ISerializationContext context, MethodDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MethodImplementation returns MethodImplementation
	 *
	 * Constraint:
	 *     (expression=Expression | (structuredID=StructuredID argumentList=ArgumentList?))
	 * </pre>
	 */
	protected void sequence_MethodImplementation(ISerializationContext context, MethodImplementation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MethodInvocation returns PostfixExp
	 *
	 * Constraint:
	 *     (primaryExp=PrimaryExp tail+=PostfixExpTail* argumentList+=ArgumentList?)
	 * </pre>
	 */
	protected void sequence_MethodInvocation_PostfixExp(ISerializationContext context, PostfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns ModifierDeclaration
	 *     ModifierDeclaration returns ModifierDeclaration
	 *
	 * Constraint:
	 *     (actorName=ID? modifierName=ID qualifiedBehaviorName=ID? (ScenarioMemberDecl+=MemberDeclaration | BehaviorSpecification+=OnDirective)*)
	 * </pre>
	 */
	protected void sequence_ModifierDeclaration(ISerializationContext context, ModifierDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamedArgument returns NamedArgument
	 *
	 * Constraint:
	 *     (argumentName=ID? expression=Expression argumentList=ArgumentList?)
	 * </pre>
	 */
	protected void sequence_NamedArgument(ISerializationContext context, NamedArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtensionMemberDeclaration returns OnDirective
	 *     BehaviorSpecification returns OnDirective
	 *     OnDirective returns OnDirective
	 *
	 * Constraint:
	 *     (eventSpecification=ID onMember+=OnDirectiveMember*)
	 * </pre>
	 */
	protected void sequence_OnDirective(ISerializationContext context, OnDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscFile returns OscFile
	 *
	 * Constraint:
	 *     ((preludeStatements+=PreludeStatement+ oscDeclarations+=OscDeclaration+) | oscDeclarations+=OscDeclaration+)?
	 * </pre>
	 */
	protected void sequence_OscFile(ISerializationContext context, OscFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtensionMemberDeclaration returns ParameterDeclaration
	 *     ParameterDeclaration returns ParameterDeclaration
	 *     MemberDeclaration returns ParameterDeclaration
	 *     FieldDeclaration returns ParameterDeclaration
	 *
	 * Constraint:
	 *     (fieldName=ID NextfieldName+=ID* typeDeclarator=TypeDeclarator defaultValue=Expression? withDeclaration=ParameterWithDeclaration?)
	 * </pre>
	 */
	protected void sequence_ParameterDeclaration(ISerializationContext context, ParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterReference returns PostfixExp
	 *
	 * Constraint:
	 *     (primaryExp=PrimaryExp tail+=PostfixExpTail* fieldName+=ID)
	 * </pre>
	 */
	protected void sequence_ParameterReference_PostfixExp(ISerializationContext context, PostfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterWithDeclaration returns ParameterWithDeclaration
	 *
	 * Constraint:
	 *     parameterWithMembers+=ConstraintDeclaration+
	 * </pre>
	 */
	protected void sequence_ParameterWithDeclaration(ISerializationContext context, ParameterWithDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns PhysicalTypeDeclaration
	 *     PhysicalTypeDeclaration returns PhysicalTypeDeclaration
	 *
	 * Constraint:
	 *     (physicalTypeName=ID baseUnitSpecifier=SIBaseUnitSpecifier)
	 * </pre>
	 */
	protected void sequence_PhysicalTypeDeclaration(ISerializationContext context, PhysicalTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.PHYSICAL_TYPE_DECLARATION__PHYSICAL_TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.PHYSICAL_TYPE_DECLARATION__PHYSICAL_TYPE_NAME));
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.PHYSICAL_TYPE_DECLARATION__BASE_UNIT_SPECIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.PHYSICAL_TYPE_DECLARATION__BASE_UNIT_SPECIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPhysicalTypeDeclarationAccess().getPhysicalTypeNameIDTerminalRuleCall_1_0(), semanticObject.getPhysicalTypeName());
		feeder.accept(grammarAccess.getPhysicalTypeDeclarationAccess().getBaseUnitSpecifierSIBaseUnitSpecifierParserRuleCall_3_0(), semanticObject.getBaseUnitSpecifier());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExp returns PhysicalType
	 *     ValueExp returns PhysicalType
	 *     PhysicalType returns PhysicalType
	 *
	 * Constraint:
	 *     ((numberInteger=INTEGER | numberFloat=FLOAT) (unitBaseName=SIBaseUnitName | unitName=ID)?)
	 * </pre>
	 */
	protected void sequence_PhysicalType(ISerializationContext context, PhysicalType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExp returns PostfixExp
	 *     Factor returns PostfixExp
	 *
	 * Constraint:
	 *     (primaryExp=PrimaryExp tail+=PostfixExpTail*)
	 * </pre>
	 */
	protected void sequence_PostfixExp(ISerializationContext context, PostfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventCondition returns PostfixExp
	 *     Expression returns PostfixExp
	 *     Relation returns PostfixExp
	 *
	 * Constraint:
	 *     (
	 *         primaryExp=PrimaryExp 
	 *         tail+=PostfixExpTail* 
	 *         (multiplicativeOp+=MultiplicativeOp nextFactor+=Factor)* 
	 *         (additiveOp+=AdditiveOp nextTerm+=Term)* 
	 *         (relationalOp+=RelationalOp nextSum+=Sum)*
	 *     )
	 * </pre>
	 */
	protected void sequence_PostfixExp_Relation_Sum_Term(ISerializationContext context, PostfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Sum returns PostfixExp
	 *
	 * Constraint:
	 *     (primaryExp=PrimaryExp tail+=PostfixExpTail* (multiplicativeOp+=MultiplicativeOp nextFactor+=Factor)* (additiveOp+=AdditiveOp nextTerm+=Term)*)
	 * </pre>
	 */
	protected void sequence_PostfixExp_Sum_Term(ISerializationContext context, PostfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Term returns PostfixExp
	 *
	 * Constraint:
	 *     (primaryExp=PrimaryExp tail+=PostfixExpTail* (multiplicativeOp+=MultiplicativeOp nextFactor+=Factor)*)
	 * </pre>
	 */
	protected void sequence_PostfixExp_Term(ISerializationContext context, PostfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrimaryExp returns RangeConstructor
	 *     RangeConstructor returns RangeConstructor
	 *
	 * Constraint:
	 *     ((start=ValueExp end=ValueExp) | (start=ValueExp end=ValueExp))
	 * </pre>
	 */
	protected void sequence_RangeConstructor(ISerializationContext context, RangeConstructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtensionMemberDeclaration returns RemoveDefaultDeclaration
	 *     MemberDeclaration returns RemoveDefaultDeclaration
	 *     BehaviorWithMember returns RemoveDefaultDeclaration
	 *     ConstraintDeclaration returns RemoveDefaultDeclaration
	 *     RemoveDefaultDeclaration returns RemoveDefaultDeclaration
	 *
	 * Constraint:
	 *     parameterReference=ParameterReference
	 * </pre>
	 */
	protected void sequence_RemoveDefaultDeclaration(ISerializationContext context, RemoveDefaultDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.REMOVE_DEFAULT_DECLARATION__PARAMETER_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.REMOVE_DEFAULT_DECLARATION__PARAMETER_REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveDefaultDeclarationAccess().getParameterReferenceParameterReferenceParserRuleCall_2_0(), semanticObject.getParameterReference());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EventCondition returns RiseExpression
	 *     RiseExpression returns RiseExpression
	 *
	 * Constraint:
	 *     boolExpression=Expression
	 * </pre>
	 */
	protected void sequence_RiseExpression(ISerializationContext context, RiseExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.RISE_EXPRESSION__BOOL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.RISE_EXPRESSION__BOOL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRiseExpressionAccess().getBoolExpressionExpressionParserRuleCall_2_0(), semanticObject.getBoolExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SIBaseExponentList returns SIBaseExponentList
	 *
	 * Constraint:
	 *     (SIBaseExponentList=SIBaseExponent NextSIBaseExponentList+=SIBaseExponent*)
	 * </pre>
	 */
	protected void sequence_SIBaseExponentList(ISerializationContext context, SIBaseExponentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SIBaseExponent returns SIBaseExponent
	 *
	 * Constraint:
	 *     (unit=SIBaseUnitName number=INTEGER)
	 * </pre>
	 */
	protected void sequence_SIBaseExponent(ISerializationContext context, SIBaseExponent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.SI_BASE_EXPONENT__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.SI_BASE_EXPONENT__UNIT));
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.SI_BASE_EXPONENT__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.SI_BASE_EXPONENT__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSIBaseExponentAccess().getUnitSIBaseUnitNameParserRuleCall_0_0(), semanticObject.getUnit());
		feeder.accept(grammarAccess.getSIBaseExponentAccess().getNumberINTEGERTerminalRuleCall_2_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SIBaseUnitSpecifier returns SIBaseUnitSpecifier
	 *
	 * Constraint:
	 *     SIBaseExponentList=SIBaseExponentList
	 * </pre>
	 */
	protected void sequence_SIBaseUnitSpecifier(ISerializationContext context, SIBaseUnitSpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.SI_BASE_UNIT_SPECIFIER__SI_BASE_EXPONENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.SI_BASE_UNIT_SPECIFIER__SI_BASE_EXPONENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSIBaseUnitSpecifierAccess().getSIBaseExponentListSIBaseExponentListParserRuleCall_2_0(), semanticObject.getSIBaseExponentList());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SIUnitSpecifier returns SIUnitSpecifier
	 *
	 * Constraint:
	 *     (SIBaseExponentList=SIBaseExponentList SIfactor=SIUnitFactor? SIUnit=SIUnitOffset?)
	 * </pre>
	 */
	protected void sequence_SIUnitSpecifier(ISerializationContext context, SIUnitSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SampleExpression returns SampleExpression
	 *
	 * Constraint:
	 *     (expression=Expression eventSpecification=EventSpecification defaultValue=Expression?)
	 * </pre>
	 */
	protected void sequence_SampleExpression(ISerializationContext context, SampleExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns ScenarioDeclaration
	 *     ScenarioDeclaration returns ScenarioDeclaration
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (baseScenarioName=ID (fieldName=ID enumReference=EnumValueReference?)?)? 
	 *         (ScenarioMemberDecl+=MemberDeclaration | BehaviorSpecification+=BehaviorSpecification)*
	 *     )
	 * </pre>
	 */
	protected void sequence_ScenarioDeclaration(ISerializationContext context, ScenarioDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns StructDeclaration
	 *     StructDeclaration returns StructDeclaration
	 *
	 * Constraint:
	 *     (name=ID (baseStructName=ID (fieldName=ID enumReference=EnumValueReference?)?)? StructMemberDecl+=MemberDeclaration*)
	 * </pre>
	 */
	protected void sequence_StructDeclaration(ISerializationContext context, StructDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImportReference returns StructuredID
	 *     StructuredID returns StructuredID
	 *
	 * Constraint:
	 *     (identifier+=ID identifier+=ID*)
	 * </pre>
	 */
	protected void sequence_StructuredID(ISerializationContext context, StructuredID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns StructuredTypeExtension
	 *     TypeExtension returns StructuredTypeExtension
	 *     StructuredTypeExtension returns StructuredTypeExtension
	 *
	 * Constraint:
	 *     (extendableTypeName=ID extensionMemberDecls+=ExtensionMemberDeclaration*)
	 * </pre>
	 */
	protected void sequence_StructuredTypeExtension(ISerializationContext context, StructuredTypeExtension semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixExpTail returns TypeTestTail
	 *     TypeTestTail returns TypeTestTail
	 *
	 * Constraint:
	 *     typeDeclarator+=TypeDeclarator
	 * </pre>
	 */
	protected void sequence_TypeTestTail(ISerializationContext context, TypeTestTail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OscDeclaration returns UnitDeclaration
	 *     UnitDeclaration returns UnitDeclaration
	 *
	 * Constraint:
	 *     (unitName=ID physicalTypeName=ID unitSpecifier=SIUnitSpecifier)
	 * </pre>
	 */
	protected void sequence_UnitDeclaration(ISerializationContext context, UnitDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.UNIT_DECLARATION__UNIT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.UNIT_DECLARATION__UNIT_NAME));
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.UNIT_DECLARATION__PHYSICAL_TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.UNIT_DECLARATION__PHYSICAL_TYPE_NAME));
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.UNIT_DECLARATION__UNIT_SPECIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.UNIT_DECLARATION__UNIT_SPECIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnitDeclarationAccess().getUnitNameIDTerminalRuleCall_1_0(), semanticObject.getUnitName());
		feeder.accept(grammarAccess.getUnitDeclarationAccess().getPhysicalTypeNameIDTerminalRuleCall_3_0(), semanticObject.getPhysicalTypeName());
		feeder.accept(grammarAccess.getUnitDeclarationAccess().getUnitSpecifierSIUnitSpecifierParserRuleCall_5_0(), semanticObject.getUnitSpecifier());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BehaviorWithMember returns UntilDirective
	 *     UntilDirective returns UntilDirective
	 *
	 * Constraint:
	 *     eventSpecification=EventSpecification
	 * </pre>
	 */
	protected void sequence_UntilDirective(ISerializationContext context, UntilDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.UNTIL_DIRECTIVE__EVENT_SPECIFICATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.UNTIL_DIRECTIVE__EVENT_SPECIFICATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUntilDirectiveAccess().getEventSpecificationEventSpecificationParserRuleCall_1_0(), semanticObject.getEventSpecification());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtensionMemberDeclaration returns VariableDeclaration
	 *     MemberDeclaration returns VariableDeclaration
	 *     FieldDeclaration returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (fieldName=ID NextfieldName+=ID* typeDeclarator=TypeDeclarator (defaultValue=Expression | sampleExpression=SampleExpression)?)
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WaitDirective returns WaitDirective
	 *
	 * Constraint:
	 *     eventSpecification=EventSpecification
	 * </pre>
	 */
	protected void sequence_WaitDirective(ISerializationContext context, WaitDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenScenarioPackage.Literals.WAIT_DIRECTIVE__EVENT_SPECIFICATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenScenarioPackage.Literals.WAIT_DIRECTIVE__EVENT_SPECIFICATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWaitDirectiveAccess().getEventSpecificationEventSpecificationParserRuleCall_1_0(), semanticObject.getEventSpecification());
		feeder.finish();
	}
	
	
}
